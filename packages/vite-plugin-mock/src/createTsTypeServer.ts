import type { ViteMockOptions, Recordable } from './types'

import path from 'node:path'
import fs from 'node:fs'
import chokidar from 'chokidar'
import fg from 'fast-glob'

import { isAbsPath, loggerOutput, likeStrToStr } from './utils'
import type { ResolvedConfig } from 'vite'
import { parse, Lang } from '@ast-grep/napi'
export let requestTsData: Recordable = {}
export const zybAbsMockPath = ''
export async function createRequestTsServer(
  opt: ViteMockOptions = { mockPath: 'mock', configPath: 'vite.mock.config' },
  config: ResolvedConfig,
) {
  opt = {
    mockPath: 'mock',
    watchFiles: true,
    configPath: 'vite.mock.config.ts',
    logger: true,
    cors: true,
    prefix: '/api',
    ...opt,
  }

  if (requestTsData.length > 0) return
  requestTsData = await getTsType(opt, config)
  await createWatch(opt, config)
}

// create watch mock
function createWatch(opt: ViteMockOptions, config: ResolvedConfig) {
  const { logger, watchFiles } = opt

  if (!watchFiles) {
    return
  }

  const { absRequestPath } = getPath(opt)

  if (process.env.VITE_DISABLED_WATCH_MOCK === 'true') {
    return
  }

  const watchDir = [absRequestPath]

  const watcher = chokidar.watch(watchDir, {
    ignoreInitial: true,
    // ignore files generated by `bundle require`
    ignored: '**/_*.bundled_*.(mjs|cjs)',
  })

  watcher.on('all', async (event, file) => {
    logger && loggerOutput(`mock file ${event}`, file)
    requestTsData = await getTsType(opt, config)
  })
}

// load mock .ts files and watch
async function getTsType(opt: ViteMockOptions, config: ResolvedConfig) {
  const requestMap: Recordable = {}
  if (!opt.requestPath) {
    return requestMap
  }

  const { absRequestPath } = getPath(opt)
  if (!absRequestPath) {
    return requestMap
  }
  // const { ignore, configPath, logger } = opt

  const mockFiles = fg.sync(`**/*.{ts,mjs,js}`, {
    cwd: absRequestPath,
  })

  try {
    let requestMap: Recordable = {}
    for (let index = 0; index < mockFiles.length; index++) {
      const mockFile = mockFiles[index]
      requestMap = {
        ...requestMap,
        ...extractRequestInfo(path.join(absRequestPath, mockFile), opt),
      }
    }
    return requestMap
  } catch (error: any) {
    loggerOutput(`mock reload error`, error)
    return requestMap
  }
}

// get custom config file path and mock dir path
function getPath(opt: ViteMockOptions) {
  const { requestPath } = opt
  const cwd = process.cwd()
  const absRequestPath = isAbsPath(requestPath) ? requestPath! : path.join(cwd, requestPath || '')
  return {
    absRequestPath,
  }
}

// 用于提取请求相关信息的主函数
function extractRequestInfo(filePath: string, opt: ViteMockOptions): Recordable {
  const fileContent: string = fs.readFileSync(filePath, 'utf8')
  const map: Recordable = {}
  const ast = parse(Lang.TypeScript, fileContent)
  const root = ast.root() // root is an instance of SgNode

  const exportFuns = root.findAll(`export function $NAME($$$:$REQ_TYPE):Promise<$RES_TYPE> {
      return $$$($URL,$$$)
    }`) // search node
  exportFuns.forEach((exportFun) => {
    const req = exportFun?.getMatch('REQ_TYPE') // get matched variable
    const res = exportFun?.getMatch('RES_TYPE') // get matched variable
    let url = exportFun?.getMatch('URL')?.text() // get matched variable
    if (!url) {
      return
    }
    url = `${opt.prefix || ''}${likeStrToStr(url)}`

    const typeObj: Recordable = {}
    if (req) {
      // console.log(req?.text())
      const reqFindStr = `interface ${req?.text()} {$$$}`
      const reqType = root.find(reqFindStr)
      if (reqType) {
        typeObj.reqType = reqType?.text()
      }
    }
    if (res) {
      const resFindStr = `interface ${res?.text()} {$$$}`
      const resType = root.find(resFindStr)
      if (resType) {
        typeObj.resType = resType?.text()
      }
    }
    map[url] = typeObj
  })
  return map
}
