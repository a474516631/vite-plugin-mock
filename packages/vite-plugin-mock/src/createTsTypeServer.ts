import type { ViteMockOptions, Recordable } from './types'

import path from 'node:path'
import fs from 'node:fs'
import chokidar from 'chokidar'
import fg from 'fast-glob'

import { isAbsPath, loggerOutput, likeStrToStr } from './utils'
import type { ResolvedConfig } from 'vite'
import { parse, Lang } from '@ast-grep/napi'
export let requestTsData: Recordable = {}
export const zybAbsMockPath = ''
export async function createRequestTsServer(
  opt: ViteMockOptions = { mockPath: 'mock', configPath: 'vite.mock.config' },
  config: ResolvedConfig,
) {
  opt = {
    mockPath: 'mock',
    watchFiles: true,
    configPath: 'vite.mock.config.ts',
    logger: true,
    cors: true,
    prefix: '/api',
    ...opt,
  }

  if (requestTsData.length > 0) return
  requestTsData = await getTsType(opt, config)
  await createWatch(opt, config)
}

// create watch mock
function createWatch(opt: ViteMockOptions, config: ResolvedConfig) {
  const { logger, watchFiles } = opt

  if (!watchFiles) {
    return
  }

  const { absRequestPath } = getPath(opt)

  if (process.env.VITE_DISABLED_WATCH_MOCK === 'true') {
    return
  }

  const watchDir = [absRequestPath]

  const watcher = chokidar.watch(watchDir, {
    ignoreInitial: true,
    // ignore files generated by `bundle require`
    ignored: '**/_*.bundled_*.(mjs|cjs)',
  })

  watcher.on('all', async (event, file) => {
    logger && loggerOutput(`request file ${event}`, file)
    requestTsData = await getTsType(opt, config)
  })
}

// load mock .ts files and watch
async function getTsType(opt: ViteMockOptions, config: ResolvedConfig) {
  const requestMap: Recordable = {}
  if (!opt.requestPath) {
    return requestMap
  }

  const { absRequestPath } = getPath(opt)
  if (!absRequestPath) {
    return requestMap
  }
  // const { ignore, configPath, logger } = opt

  const mockFiles = fg.sync(`**/*.{ts,mjs,js}`, {
    cwd: absRequestPath,
  })

  try {
    let requestMap: Recordable = {}
    for (let index = 0; index < mockFiles.length; index++) {
      const mockFile = mockFiles[index]
      requestMap = {
        ...requestMap,
        ...extractRequestInfo(path.join(absRequestPath, mockFile), opt),
      }
    }
    return requestMap
  } catch (error: any) {
    loggerOutput(`mock reload error`, error)
    return requestMap
  }
}

// get custom config file path and mock dir path
function getPath(opt: ViteMockOptions) {
  const { requestPath } = opt
  const cwd = process.cwd()
  const absRequestPath = isAbsPath(requestPath) ? requestPath! : path.join(cwd, requestPath || '')
  return {
    absRequestPath,
  }
}

// 用于提取请求相关信息的主函数
function extractRequestInfo(filePath: string, opt: ViteMockOptions): Recordable {
  const fileContent: string = fs.readFileSync(filePath, 'utf8')
  const map: Recordable = {}
  const ast = parse(Lang.TypeScript, fileContent)
  const root = ast.root()

  try {
    // 定义多个匹配模式，使用 $$$? 表示可选匹配
    const patterns = opt.findInterfaceType
      ? [opt.findInterfaceType]
      : [
          // Promise 风格 - 支持可选泛型
          `export function $NAME($$$:$REQ_TYPE?):Promise<$RES_TYPE?> {
        return $$$<$$$?>($URL,$$$)
      }`,

          // axios 风格 - 支持可选泛型
          `export function $NAME($$$:$REQ_TYPE?) {
        return axios<$RES_TYPE?>({
          url: $URL,
          $$$
        })
      }`,

          // request 方法风格 - 支持可选泛型和可选参数
          `export function $NAME($$$?) {
        return request<$RES_TYPE?>($URL,$$$?)
      }`,

          // 箭头函数风格 - 支持可选类型
          `export const $NAME = ($$$:$REQ_TYPE?):Promise<$RES_TYPE?> => {
        return $$$<$$$?>($URL,$$$)
      }`,
        ]

    // 遍历所有模式进行匹配
    for (const pattern of patterns) {
      const exportFuns = root.findAll(pattern)
      exportFuns.forEach((exportFun) => {
        const req = exportFun?.getMatch('REQ_TYPE')
        const res = exportFun?.getMatch('RES_TYPE')
        let url = exportFun?.getMatch('URL')?.text()

        if (!url) return

        url = `${opt.prefix || ''}${likeStrToStr(url)}`
        const typeObj: Recordable = {}
        if (req && req?.kind() === 'type_identifier') {
          // console.log(req?.text())
          const reqFindStr = `interface ${req?.text()} {$$$}`
          const reqType = root.find(reqFindStr)
          if (reqType) {
            typeObj.reqType = reqType?.text()
          }
        } else if (req && req?.kind() === 'object_type') {
          typeObj.reqType = req?.text()
        }
        if (res && res?.kind() === 'type_identifier') {
          const resFindStr = `interface ${res?.text()} {$$$}`
          const resType = root.find(resFindStr)
          if (resType) {
            typeObj.resType = resType?.text()
          }
          if (url === '/api/assistantdesk/api/sop/getstudentcallrecordinfobl') {
            console.log('@@@@@@@@@@@@', res?.text())
          }
        } else if (res && res?.kind() === 'object_type') {
          typeObj.resType = res?.text()
        }
        map[url] = typeObj
      })
    }
  } catch (error) {
    console.log(error)
  }

  return map
}
